cd build
cmake ..
make
./Introduction

Codar no arquivo
image.fs.frag 

Código 1: 
float dist(vec2 p, float r)
{
    float d= length(p)-r;
    return smoothstep(r,r+0.001,d);
}


void main ()
{
    vec2 p = gl_FragCoord.xy/iResolution.xy;
     vec3 col =mix(vec3(0.9,0.3,0.1),vec3(0.7,0.5,0.3),p.y);
     float ra =iResolution.x/iResolution.y;
     p.x*=ra;
     float r =0.06;
     vec2 q = p -vec2(0.5,0.7);
     r+=0.027*cos(atan(q.x,q.y)*15-20*q.x+ 2*sin(iTime*1.2));
     r+=0.01*sin(atan(q.x,q.y)*90.0);
      col*=dist(q,r);

      r=0.02;
      r+= 0.005*cos(q.y*130);

      r+=exp(-40*p.y);
     col*=1.0-(1.0-smoothstep(r,r+0.001,abs(q.x-0.3*sin(q.y*2.2))))*(1.0-smoothstep(0.0,0.1,q.y));

    vec2 s = vec2(1.0, 0.4);
    vec2 t = p - s;
    col = mix(
        vec3(1.0, 0.8, 0.0),
        col,
        dist(t, 0.1+sin(atan(t.x, t.y)*180.0)*0.005)
    );

C = vec4(col,1.0);

}

Código 2 (ray tracing):

float minDist = 0.01;
float maxDist = 100.;
int maxIt = 100;

float sphereDist(vec3 p)
{
    vec4 s =vec4(0.0,1.0,5.0,1.0);
    return length(s.xyz-p)-s.w;
}

float planeDist(vec3 p)
{
    vec4 plane = vec4(0.0,1.0,0.0,0.0);
    return dot(p,plane.xyz)-plane.w;
}

float getSceneDist(vec3 p)
{
    float sd = sphereDist(p);
    float pd = planeDist(p);
    return min(sd,pd);
}

float rayMarching(vec3 ro,vec3 rd)
{
    int i=0;
    float da=0.0;
    vec3 p = ro+da*rd;
    float d_o =getSceneDist(p);
    while ((da<maxDist)&&(d_o>minDist)&&(i<maxIt))
    {
        da+=d_o;
        p =ro+da*rd;
        d_o =getSceneDist(p);
        i++;
    }
    if((i<maxIt)&&(da<maxDist))
        return da;
    else
        return maxDist;
}

vec3 estimateNormal(vec3 p)
{
    float ep = 0.01;
    float d = getSceneDist(p);
    vec3 n =vec3 (d-getSceneDist(vec3(p.x-ep,p.y,p.z)),d-getSceneDist(vec3(p.x,p.y-ep,p.z)),d-getSceneDist(vec3(p.x,p.y,p.z-ep)));
    return normalize(n);
}


float getLight(vec3 p)
{
    vec3 lp = vec3 (0.0,6.0,5.0);
    lp.xz+=vec2(sin(iTime),cos(iTime))*3.0;
    vec3 ld = normalize(lp-p);
    vec3 n = estimateNormal(p);
    float r =clamp(dot(ld,n),0.0,1.0);
    float s =rayMarching(p+1.0*minDist*n,ld);
    if(s<length(p-lp))
        r*=0.2;
    return r;

}



void main ()
{
    vec2 uv = (gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.xy;
    float ra =iResolution.x/iResolution.y;
    uv.x*=ra;

    vec3 ro = vec3(0.0,1.0,0.0);
    vec3 rd =vec3(uv.x,uv.y,1.0);
     float d = rayMarching(ro,rd);
    vec3 p = ro+d*rd;
    float l = getLight(p);
   vec3 col = vec3(l);
C = vec4(col,1.0);

}

Cód 3: Curvas
